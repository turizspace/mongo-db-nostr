{
  "version": 3,
  "sources": ["../../nip44.ts"],
  "sourcesContent": ["import { chacha20 } from '@noble/ciphers/chacha'\nimport { ensureBytes, equalBytes } from '@noble/ciphers/utils'\nimport { secp256k1 } from '@noble/curves/secp256k1'\nimport { extract as hkdf_extract, expand as hkdf_expand } from '@noble/hashes/hkdf'\nimport { hmac } from '@noble/hashes/hmac'\nimport { sha256 } from '@noble/hashes/sha256'\nimport { concatBytes, randomBytes, utf8ToBytes } from '@noble/hashes/utils'\nimport { base64 } from '@scure/base'\n\nconst decoder = new TextDecoder()\nconst u = {\n  minPlaintextSize: 0x0001, // 1b msg => padded to 32b\n  maxPlaintextSize: 0xffff, // 65535 (64kb-1) => padded to 64kb\n\n  utf8Encode: utf8ToBytes,\n  utf8Decode(bytes: Uint8Array) {\n    return decoder.decode(bytes)\n  },\n\n  getConversationKey(privkeyA: string, pubkeyB: string): Uint8Array {\n    const sharedX = secp256k1.getSharedSecret(privkeyA, '02' + pubkeyB).subarray(1, 33)\n    return hkdf_extract(sha256, sharedX, 'nip44-v2')\n  },\n\n  getMessageKeys(conversationKey: Uint8Array, nonce: Uint8Array) {\n    ensureBytes(conversationKey, 32)\n    ensureBytes(nonce, 32)\n    const keys = hkdf_expand(sha256, conversationKey, nonce, 76)\n    return {\n      chacha_key: keys.subarray(0, 32),\n      chacha_nonce: keys.subarray(32, 44),\n      hmac_key: keys.subarray(44, 76),\n    }\n  },\n\n  calcPaddedLen(len: number): number {\n    if (!Number.isSafeInteger(len) || len < 1) throw new Error('expected positive integer')\n    if (len <= 32) return 32\n    const nextPower = 1 << (Math.floor(Math.log2(len - 1)) + 1)\n    const chunk = nextPower <= 256 ? 32 : nextPower / 8\n    return chunk * (Math.floor((len - 1) / chunk) + 1)\n  },\n\n  writeU16BE(num: number) {\n    if (!Number.isSafeInteger(num) || num < u.minPlaintextSize || num > u.maxPlaintextSize)\n      throw new Error('invalid plaintext size: must be between 1 and 65535 bytes')\n    const arr = new Uint8Array(2)\n    new DataView(arr.buffer).setUint16(0, num, false)\n    return arr\n  },\n\n  pad(plaintext: string): Uint8Array {\n    const unpadded = u.utf8Encode(plaintext)\n    const unpaddedLen = unpadded.length\n    const prefix = u.writeU16BE(unpaddedLen)\n    const suffix = new Uint8Array(u.calcPaddedLen(unpaddedLen) - unpaddedLen)\n    return concatBytes(prefix, unpadded, suffix)\n  },\n\n  unpad(padded: Uint8Array): string {\n    const unpaddedLen = new DataView(padded.buffer).getUint16(0)\n    const unpadded = padded.subarray(2, 2 + unpaddedLen)\n    if (\n      unpaddedLen < u.minPlaintextSize ||\n      unpaddedLen > u.maxPlaintextSize ||\n      unpadded.length !== unpaddedLen ||\n      padded.length !== 2 + u.calcPaddedLen(unpaddedLen)\n    )\n      throw new Error('invalid padding')\n    return u.utf8Decode(unpadded)\n  },\n\n  hmacAad(key: Uint8Array, message: Uint8Array, aad: Uint8Array) {\n    if (aad.length !== 32) throw new Error('AAD associated data must be 32 bytes')\n    const combined = concatBytes(aad, message)\n    return hmac(sha256, key, combined)\n  },\n\n  // metadata: always 65b (version: 1b, nonce: 32b, max: 32b)\n  // plaintext: 1b to 0xffff\n  // padded plaintext: 32b to 0xffff\n  // ciphertext: 32b+2 to 0xffff+2\n  // raw payload: 99 (65+32+2) to 65603 (65+0xffff+2)\n  // compressed payload (base64): 132b to 87472b\n  decodePayload(payload: string) {\n    if (typeof payload !== 'string') throw new Error('payload must be a valid string')\n    const plen = payload.length\n    if (plen < 132 || plen > 87472) throw new Error('invalid payload length: ' + plen)\n    if (payload[0] === '#') throw new Error('unknown encryption version')\n    let data: Uint8Array\n    try {\n      data = base64.decode(payload)\n    } catch (error) {\n      throw new Error('invalid base64: ' + (error as any).message)\n    }\n    const dlen = data.length\n    if (dlen < 99 || dlen > 65603) throw new Error('invalid data length: ' + dlen)\n    const vers = data[0]\n    if (vers !== 2) throw new Error('unknown encryption version ' + vers)\n    return {\n      nonce: data.subarray(1, 33),\n      ciphertext: data.subarray(33, -32),\n      mac: data.subarray(-32),\n    }\n  },\n}\n\nfunction encrypt(plaintext: string, conversationKey: Uint8Array, nonce = randomBytes(32)): string {\n  const { chacha_key, chacha_nonce, hmac_key } = u.getMessageKeys(conversationKey, nonce)\n  const padded = u.pad(plaintext)\n  const ciphertext = chacha20(chacha_key, chacha_nonce, padded)\n  const mac = u.hmacAad(hmac_key, ciphertext, nonce)\n  return base64.encode(concatBytes(new Uint8Array([2]), nonce, ciphertext, mac))\n}\n\nfunction decrypt(payload: string, conversationKey: Uint8Array): string {\n  const { nonce, ciphertext, mac } = u.decodePayload(payload)\n  const { chacha_key, chacha_nonce, hmac_key } = u.getMessageKeys(conversationKey, nonce)\n  const calculatedMac = u.hmacAad(hmac_key, ciphertext, nonce)\n  if (!equalBytes(calculatedMac, mac)) throw new Error('invalid MAC')\n  const padded = chacha20(chacha_key, chacha_nonce, ciphertext)\n  return u.unpad(padded)\n}\n\nexport const v2 = {\n  utils: u,\n  encrypt,\n  decrypt,\n}\n\nexport default { v2 }\n"],
  "mappings": "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",
  "names": ["import_utils", "hkdf_extract", "hkdf_expand"]
}
